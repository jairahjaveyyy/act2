import { Alias } from '../nodes/Alias.js';
import { isEmptyPath, collectionFromPath } from '../nodes/Collection.js';
import { NODE_TYPE, DOC, isNode, isCollection, isScalar } from '../nodes/identity.js';
import { Pair } from '../nodes/Pair.js';
import { toJS } from '../nodes/toJS.js';
import { Schema } from '../schema/Schema.js';
import { stringifyDocument } from '../stringify/stringifyDocument.js';
import { anchorNames, findNewAnchor, createNodeAnchors } from './anchors.js';
import { applyReviver } from './applyReviver.js';
import { createNode } from './createNode.js';
import { Directives } from './directives.js';

class Document {
    constructor(value, replacer, options) {
        /** A comment before this Document */
        this.commentBefore = null;
        /** A comment immediately after this Document */
        this.comment = null;
        /** Errors encountered during parsing. */
        this.errors = [];
        /** Warnings encountered during parsing. */
        this.warnings = [];
        Object.defineProperty(this, NODE_TYPE, { value: DOC });
        let _replacer = null;
        if (typeof replacer === 'function' || Array.isArray(replacer)) {
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const opt = Object.assign({
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: 'warn',
            prettyErrors: true,
            strict: true,
            uniqueKeys: true,
            version: '1.2'
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
            this.directives = options._directives.atDocument();
            if (this.directives.yaml.explicit)
                version = this.directives.yaml.version;
        }
        else
            this.directives = new Directives({ version });
        this.setSchema(version, options);
        // @ts-expect-error We can't really know that this matches Contents.
        this.contents =
            value === undefined ? null : this.createNode(value, _replacer, options);
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */
    clone() {
        const copy = Object.create(Document.prototype, {
            [NODE_TYPE]: { value: DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
            copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        // @ts-expect-error We can't really know that this matches Contents.
        copy.contents = isNode(this.contents)
            ? this.contents.clone(copy.schema)
            : this.contents;
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** Adds a value to the document. */
    add(value) {
        if (assertCollection(this.contents))
            this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path, value) {
        if (assertCollection(this.contents))
            this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name) {
        if (!node.anchor) {
            const prev = anchorNames(this);
            node.anchor =
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                !name || prev.has(name) ? findNewAnchor(name || 'a', prev) : name;
        }
        return new Alias(node.anchor);
    }
    createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === 'function') {
            value = replacer.call({ '': value }, '', value);
            _replacer = replacer;
        }
        else if (Array.isArray(replacer)) {
            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0)
                replacer = replacer.concat(asStr);
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, 
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || 'a');
        const ctx = {
            aliasDuplicateObjects: aliasDuplicateObjects ?? true,
            keepUndefined: keepUndefined ?? false,
            onAnchor,
            onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects
        };
        const node = createNode(value, tag, ctx);
        if (flow && isCollection(node))
            node.flow = true;
        setAnchors();
        return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        if (isEmptyPath(path)) {
            if (this.contents == null)
                return false;
            // @ts-expect-error Presumed impossible if Strict extends false
            this.contents = null;
            return true;
        }
        return assertCollection(this.contents)
            ? this.contents.deleteIn(path)
            : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
        return isCollection(this.contents)
            ? this.contents.get(key, keepScalar)
            : undefined;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        if (isEmptyPath(path))
            return !keepScalar && isScalar(this.contents)
                ? this.contents.value
                : this.contents;
        return isCollection(this.contents)
            ? this.contents.getIn(path, keepScalar)
            : undefined;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
        return isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path) {
        if (isEmptyPath(path))
            return this.contents !== undefined;
        return isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    /**
     * Se)bU
eHni_lR{:ʚ$A4kl0`0Dg~PED~Bfnک1ymǅ܋j`^ҫtݿȟ=/#C:ͥ9V{1CJwv+N-
T\PZ..t >Ӑisx@5
El~\oP5K7 Qכf3,ҿgkF5Qyփ.^\NE!JY'ֳ>djo]1MnX8Wsob摸>\Wc[['ͼjJ7&*lS<UB7Gxg\<{lvL/1шS蛭K58H1+6.攪\^jAnmq׵m]G^Ic|C%2PgȇQFIۚɀn%l߽J\0x·	zVn@C $rl>':? 7@]hqkE!o-dc<od^gp$4Ys}n`XQzԃMȐ1Лx;z4.hQ emgc}P5pIp-R<f	5XM̯ R{!!\/E ZLk	r"X)(\5gKt8hы6Ӳ<#д\m)#kO
˨3/acz*3Q{!-A"
<Z]W`p?T"*g2a8Ũbvw\dY-Z'1k8ȽMq<~B#2pT &Y"P<CŃ#en">q.<|i#3YZ=x?q=ZFJP.Tj0~M.\+$Pc{'Lii!dN$6ՠ|64B"Ws:Y3LB{)bϑ[63C"NF_xUF@8O8*3g>5W
~4JlUɦl1UX_=C'I;H!0@z	Xsk(WZ.y<AxqCWלA\=9'EBKXjYRc(WuSp<6OJeY182WN|Yr9A_ao?l<v³l^TD|M4xӬ5_p=]lntƓ͇2d5\coo NEb A:[r}o~+9:6Rr=/g$̣	t]cJbFlr!N'Sǋ$ZpSe9cC[A͡m	zJn+=wDNY{
~P:	 蝹9 CV*Mu`2xE)r?{v;"(~"y穯u5O'ׅMus/462ΗO&tA:`hipaAq%`ers˸`MGJ\[N2F-?KWeN)V>s~ۤmKPFH+<Q%*0```D\Z_i_	b'mt'0tS\G#5gZz!S?Db&EK,옾6D䞧-l&\2[o/ߍ+~%Ob<3
Nhky%<Lk]Y&q~f+-!CByY*?(#-nϘyVE!uW>	ɖ.*EKveneHe1K5j|mW(3e4cs}D3)
K: J;0+fńZ;8ɒ}mJ4+MM .s㲰vG&c|!nHVHѩys3gM{R="uu>o+ޠQ2>2
v+coQCQ'(	Vެ%Gb)@q8JTvdp;=zo|.3
CW+:}]gs>o&강x}g{V!ءĶsiB@\x[ƒlA >Mmy-jZe(L&	6/b^s^~}M-oR5,V]Ecn3&}Ci 轫M|eO13q4dQ1[n[n*P,KUz3xnotms_-2%<F]O)F"W&6N$ocPZLH޻ɜ5-Ss$k@riՓ+xRr ezm.5Z_C%+ElKi"uclU
whNzUʐv~iJB_=K55x4Jm	o
gG|(ҫS{)m<wP%9h25^+h>FfZ¯FDsBt.ɸb|5{Sc̈xz IiMYabB&|R]*Zhl4!w#_#ݥrl=*jr0[Dؒ^ǻaHJnOJbQryݖ-i-tUSCtX/7Y7xrͰ ^sUv`ȓ`T~dz}	SyĤ8ee"0Ǐw;Tг2v4ң W;RP k?V1	A.	vўr$)z7R1'[fjAKoUf0I:)ߎRȑ/us1v? 
82W1sϞaZ+t{	;T!>@*k}yx:a0e%˱
8z.Ңxy%Zх5j7nE/:1(LE؜tnd䦠r-O-Ԭ-r|HbhaaQ4%@ULV;0ݠ{QaoF]r!Q/ב1HTgWiR{ZE]a[]tU|WTxRk(Z!	ǮeUĝA`-ͧ7-?LQȚ1-(63<7nYcb:BA7[~R9?rTI#nч0w;C?^Zum`}y!/e'/\[a<juTi:܎6qy}4Hbk,v]Um3dq_ٌ^>CiXjgt-Ppvl
8w?{ .\&!Y!
`$@c?"+5i)mg@[݊nc^(|HqWҍ|]YOJ\``+H*lg乆uY[Q }LBuM\cc^]mDq.{d>U>\}Wk:ٌ^r&]7T4"fAtw"s/zFILWRA<t.D)!؏F_`mב2%#\޵1t6aMk:lB}yImfq,B e.kPO;=psfR1)<:A{,^oggLO<=|o[eweP\BPphyb#F/OPFI@> 	SSg圤
r^rKz9qہC.`LL&l 5 VH?3СhFw֨JEP7pGcɗ HQR{ݼ w/|4֛pmο{m	61JCe0Fhu?7i[#Wk/1WI9WU'^d7r45]åXsE[.x՞M@BϢDAZΎGBe/I^*~rZzZCEuQ8m%J(H ]os_-^s}PTBa)3Cn?fil	r6PE767;qF-:li =@\p@J>A4< O3T%5&W\#~^i4݂4pTA =ΩLqA';O!lPEz>QWǿyyۘ2IInvƒ,s"a@mVC+[wDBRu8T-Fm>dW|pN{m?|Hwޔ_7WV|pBt;3W#NܫO}vځ@MbڊS3$UmpYo:pԟUsj5=5cJ,?MJdb~#>0.3Β