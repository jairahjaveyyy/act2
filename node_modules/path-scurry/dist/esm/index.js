import { LRUCache } from 'lru-cache';
import { posix, win32 } from 'path';
import { fileURLToPath } from 'url';
import * as actualFS from 'fs';
import { lstatSync, readdir as readdirCB, readdirSync, readlinkSync, realpathSync as rps, } from 'fs';
const realpathSync = rps.native;
// TODO: test perf of fs/promises realpath vs realpathCB,
// since the promises one uses realpath.native
import { lstat, readdir, readlink, realpath } from 'fs/promises';
import { Minipass } from 'minipass';
const defaultFS = {
    lstatSync,
    readdir: readdirCB,
    readdirSync,
    readlinkSync,
    realpathSync,
    promises: {
        lstat,
        readdir,
        readlink,
        realpath,
    },
};
// if they just gave us require('fs') then use our default
const fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS
    ? defaultFS
    : {
        ...defaultFS,
        ...fsOption,
        promises: {
            ...defaultFS.promises,
            ...(fsOption.promises || {}),
        },
    };
// turn something like //?/c:/ into c:\
const uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
const uncToDrive = (rootPath) => rootPath.replace(/\//g, '\\').replace(uncDriveRegexp, '$1\\');
// windows paths are separated by either / or \
const eitherSep = /[\\\/]/;
const UNKNOWN = 0; // may not even exist, for all we know
const IFIFO = 0b0001;
const IFCHR = 0b0010;
const IFDIR = 0b0100;
const IFBLK = 0b0110;
const IFREG = 0b1000;
const IFLNK = 0b1010;
const IFSOCK = 0b1100;
const IFMT = 0b1111;
// mask to unset low 4 bits
const IFMT_UNKNOWN = ~IFMT;
// set after successfully calling readdir() and getting entries.
const READDIR_CALLED = 0b0000_0001_0000;
// set after a successful lstat()
const LSTAT_CALLED = 0b0000_0010_0000;
// set if an entry (or one of its parents) is definitely not a dir
const ENOTDIR = 0b0000_0100_0000;
// set if an entry (or one of its parents) does not exist
// (can also be set on lstat errors like EACCES or ENAMETOOLONG)
const ENOENT = 0b0000_1000_0000;
// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK
// set if we fail to readlink
const ENOREADLINK = 0b0001_0000_0000;
// set if we know realpath() will fail
const ENOREALPATH = 0b0010_0000_0000;
const ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
const TYPEMASK = 0b0011_1111_1111;
const entToType = (s) => s.isFile()
    ? IFREG
    : s.isDirectory()
        ? IFDIR
        : s.isSymbolicLink()
            ? IFLNK
            : s.isCharacterDevice()
                ? IFCHR
                : s.isBlockDevice()
                    ? IFBLK
                    : s.isSocket()
                        ? IFSOCK
                        : s.isFIFO()
                            ? IFIFO
                            : UNKNOWN;
// normalize unicode path names
const normalizeCache = new Map();
const normalize = (s) => {
    const c = normalizeCache.get(s);
    if (c)
        return c;
    const n = s.normalize('NFKD');
    normalizeCache.set(s, n);
    return n;
};
const normalizeNocaseCache = new Map();
const normalizeNocase = (s) => {
    const c = normalizeNocaseCache.get(s);
    if (c)
        return c;
    const n = normalize(s.toLowerCase());
    normalizeNocaseCache.set(s, n);
    return n;
};
/**
 * An LRUCache for storing resolved path strings or Path objects.
 * @internal
 */
export class ResolveCache extends LRUCache {
    constructor() {
        super({ max: 256 });
    }
}
// In order to prevent blowing out the js heap by allocating hundreds of
// thousands of Path entries when walking extremely large trees, the "children"
// in this tree are represented by storing an array of Path entries in an
// LRUCache, indexed by the parent.  At any time, Path.children() may return an
// empty array, indicating that it doesn't know about any of its children, and
// thus has to rebuild that cache.  This is fine, it just means that we don't
// benefit as much from having the cached entries, but huge directory walks
// don't blow out the stack, and smaller ones are still as fast as possible.
//
//It does impose some complexity when building up the readdir data, because we
//need to pass a reference to the children array that we started with.
/**
 * an LRUCache for storing child entries.
 * @internal
 */
export class ChildrenCache extends LRUCache {
    constructor(maxSize = 16 * 1024) {
        super({
            maxSize,
            // parent + children
            sizeCalculation: a => a.length + 1,
        });
    }
}
const setAsCwd = Symbol('PathScurry setAsCwd');
/**
 * Path objects are sort of like a super-powered
 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
 *
 * Each one represents a single filesystem entry on disk, which may or may not
 * exist. It includes methods for reading various types of information via
 * lstat, readlink, and readdir, and caches all information to the greatest
 * degree possible.
 *
 * Note that fs operations that would normally throw will instead return an
 * "empty" value. This is in order to prevent excessive overhead from error
 * stack traces.
 */
export class PathBase {
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots;
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase;
    // potential default fs override
    #fs;
    // Stats fields
    #dev;
    get dev() {
        return this.#dev;
    }
    #mode;
    get mode() {
        return this.#mode;
    }
    #nlink;
    get nlink() {
        return this.#nlink;
    }
    #uid;
    get uid() {
        return this.#uid;
    }
    #gid;
    get gid() {
        return this.#gid;
    }
    #rdev;
    get rdev() {
        return this.#rdev;
    }
    #blksize;
    get blksize() {
        return this.#blksize;
    }
    #ino;
    get ino() {
        return this.#ino;
    }
    #size;
    get size() {
        return this.#size;
    }
    #blocks;
    get blocks() {
        return this.#blocks;
    }
    #atimeMs;
    get atimeMs() {
        return this.#atimeMs;
    }
    #mtimeMs;
    get mtimeMs() {
        return this.#mtimeMs;
    }
    #ctimeMs;
    get ctimeMs() {
        return this.#ctimeMs;
    }
    #birthtimeMs;
    get birthtimeMs() {
        return this.#birthtimeMs;
    }
    #atime;
    get atime() {
        return this.#atime;
    }
    #mtime;
    get mtime() {
        return this.#mtime;
    }
    #ctime;
    get ctime() {
        return this.#ctime;
    }
    #birthtime;
    get birthtime() {
        return this.#birthtime;
    }
    #matchName;
    #depth;
    #fullpath;
    #fullpathPosix;
    #relative;
    #relativePosix;
    #type;
    #children;
    #linkTarget;
    #realpath;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['path'] refers to the path of the directory
     * that was passed to readdir.  So, somewhat counterintuitively, this
     * property refers to the *parent* path, not the path object itself.
     * For root entries, it's the path to the entry itself.
     */
    get path() {
        return (this.parent || this).fullpath();
    }
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        this.name = name;
        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
        this.#type = type & TYPEMASK;
        this.nocase = nocase;
        this.roots = roots;
        this.root = root || this;
        this.#children = children;
        this.#fullpath = opts.fullpath;
        this.#relative = opts.relative;
        this.#relativePosix = opts.relativePosix;
        this.parent = opts.parent;
        if (this.parent) {
            this.#fs = this.parent.#fs;
        }
        else {
            this.#fs = fsFromOption(opts.fs);
        }
    }
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth() {
        if (this.#depth !== undefined)
            return this.#depth;
        if (!this.parent)
            return (this.#depth = 0);
        return (this.#depth = this.parent.depth() + 1);
    }
    /**
     * @internal
     */
    childrenCache() {
        return this.#children;
    }
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path) {
        if (!path) {
            return this;
        }
        const rootPath = this.getRootString(path);
        const dir = path.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath
            ? this.getRoot(rootPath).#resolveParts(dirParts)
            : this.#resolveParts(dirParts);
        return result;
    }
    #resolveParts(dirParts) {
        let p = this;
        for (const part of dirParts) {
            p = p.child(part);
        }
        return p;
    }
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children() {
        const cached = this.#children.get(this);
        if (cached) {
            return cached;
        }
        const children = Object.assign([], { provisional: 0 });
        this.#children.set(this, children);
        this.#type &= ~READDIR_CALLED;
        return children;
    }
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart, opts) {
        if (pathPart === '' || pathPart === '.') {
            return this;
        }
        if (pathPart === '..') {
            return this.parent || this;
        }
        // find the child
        const children = this.children();
        const name = this.nocase
            ? normalizeNocase(pathPart)
            : normalize(pathPart);
        for (const p of children) {
            if (p.#matchName === name) {
                return p;
            }
        }
        // didn't find it, create provisional child, since it might not
        // actually exist.  If we know the parent isn't a dir, then
        // in fact it CAN'T exist.
        const s = this.parent ? this.sep : '';
        const fullpath = this.#fullpath
            ? this.#fullpath + s + pathPart
            : undefined;
        const pchild = this.newChild(pathPart, UNKNOWN, {
            ...opts,
            parent: this,
            fullpath,
        });
        if (!this.canReaddir()) {
            pchild.#type |= ENOENT;
        }
        // don't have to update provisional, because if we have real children,
        // then provisional is set to children.length, otherwise a lower number
        children.push(pchild);
        return pchild;
    }
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative() {
        if (this.#relative !== undefined) {
            return this.#relative;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#relative = this.name);
        }
        const pv = p.relative();
        return pv + (!pv || !p.parent ? '' : this.sep) + name;
    }
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix() {
        if (this.sep === '/')
            return this.relative();
        if (this.#relativePosix !== undefined)
            return this.#relativePosix;
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#relativePosix = this.fullpathPosix());
        }
        const pv = p.relativePosix();
        return pv + (!pv || !p.parent ? '' : '/') + name;
    }
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath() {
        if (this.#fullpath !== undefined) {
            return this.#fullpath;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#fullpath = this.name);
        }
        const pv = p.fullpath();
        const fp = pv + (!p.parent ? '' : this.sep) + name;
        return (this.#fullpath = fp);
    }
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix() {
        if (this.#fullpathPosix !== undefined)
            return this.#fullpathPosix;
        if (this.sep === '/')
            return (this.#fullpathPosix = this.fullpath());
        if (!this.parent) {
            const p = this.fullpath().replace(/\\/g, '/');
            if (/^[a-z]:\//i.test(p)) {
                return (this.#fullpathPosix = `//?/${p}`);
            }
            else {
                return (this.#fullpathPosix = p);
            }
        }
        const p = this.parent;
        const pfpp = p.fullpathPosix();
        const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;
        return (this.#fullpathPosix = fpp);
    }
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown() {
        return (this.#type & IFMT) === UNKNOWN;
    }
    isType(type) {
        return this[`is${type}`]();
    }
    getType() {
        return this.isUnknown()
            ? 'Unknown'
            : this.isDirectory()
                ? 'Directory'
                : this.isFile()
                    ? 'File'
                    : this.isSymbolicLink()
                        ? 'SymbolicLink'
                        : this.isFIFO()
                            ? 'FIFO'
                            : this.isCharacterDevice()
                                ? 'CharacterDevice'
                                : this.isBlockDevice()
                                    ? 'BlockDevice'
                                    : /* c8 ignore start */ this.isSocket()
                                        ? 'Socket'
                                        : 'Unknown';
        /* c8 ignore stop */
    }
    /**
     * Is the Path a regular file?
     */
    isFile() {
        return (this.#type & IFMT) === IFREG;
    }
    /**
     * Is the Path a directory?
     */
    isDirectory() {
        return (this.#type & IFMT) === IFDIR;
    }
    /**
     * Is the path a character device?
     */
    isCharacterDevice() {
        return (this.#type & IFMT) === IFCHR;
    }
    /**
     * Is the path a block device?
     */
    isBlockDevice() {
        return (this.#type & IFMT) === IFBLK;
    }
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO() {
        return (this.#type & IFMT) === IFIFO;
    }
    /**
     * Is the path a socket?
     */
    isSocket() {
        return (this.#type & IFMT) === IFSOCK;
    }
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink() {
        return (this.#type & IFLNK) === IFLNK;
    }
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached() {
        return this.#type & LSTAT_CALLED ? this : undefined;
    }
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached() {
        return this.#linkTarget;
    }
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached() {
        return this.#realpath;
    }
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached() {
        const children = this.children();
        return children.slice(0, children.provisional);
    }
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink() {
        if (this.#linkTarget)
            return true;
        if (!this.parent)
            return false;
        // cases where it cannot possibly succeed
        const ifmt = this.#type & IFMT;
        return !((ifmt !== UNKNOWN && ifmt !== IFLNK) ||
            this.#type & ENOREADLINK ||
            this.#type & ENOENT);
    }
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir() {
        return !!(this.#type & READDIR_CALLED);
    }
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT() {
        return !!(this.#type & ENOENT);
    }
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n) {
        return !this.nocase
            ? this.#matchName === normalize(n)
            : this.#matchName === normalizeNocase(n);
    }
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    async readlink() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */
        // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */
        try {
            const read = await this.#fs.promises.readlink(this.fullpath());
            const linkTarget = (await this.parent.realpath())?.resolve(read);
            if (linkTarget) {
                return (this.#linkTarget = linkTarget);
            }
        }
        catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */
        // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */
        try {
            const read = this.#fs.readlinkSync(this.fullpath());
            const linkTarget = (this.parent.realpathSync())?.resolve(read);
            if (linkTarget) {
                return (this.#linkTarget = linkTarget);
            }
        }
        catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    #readdirSuccess(children) {
        // succeeded, mark readdir called bit
        this.#type |= READDIR_CALLED;
        // mark all remaining provisional children as ENOENT
        for (let p = children.provisional; p < children.length; p++) {
            const c = children[p];
            if (c)
                c.#markENOENT();
        }
    }
    #markENOENT() {
        // mark as UNKNOWN and ENOENT
        if (this.#type & ENOENT)
            return;
        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
        this.#markChildrenENOENT();
    }
    #markChildrenENOENT() {
        // all children are provisional and do not exist
        const children = this.children();
        children.provisional = 0;
        for (const p of children) {
            p.#markENOENT();
        }
    }
    #markENOREALPATH() {
        this.#type |= ENOREALPATH;
        this.#markENOTDIR();
    }
    // save the information when we know the entry is not a dir
    #markENOTDIR() {
        // entry is not a directory, so any children can't exist.
        // this *should* be impossible, since any children created
        // after it's been marked ENOTDIR should be marked ENOENT,
        // so it won't even get to this point.
        /* c8 ignore start */
        if (this.#type & ENOTDIR)
            return;
        /* c8 ignore stop */
        let t = this.#type;
        // this could happen if we stat a dir, then delete it,
        // then try to read it or one of its children.
        if ((t & IFMT) === IFDIR)
            t &= IFMT_UNKNOWN;
        this.#type = t | ENOTDIR;
        this.#markChildrenENOENT();
    }
    #readdirFail(code = '') {
        // markENOTDIR and markENOENT also set provisional=0
        if (code === 'ENOTDIR' || code === 'EPERM') {
            this.#markENOTDIR();
        }
        else if (code === 'ENOENT') {
            this.#markENOENT();
        }
        else {
            this.children().provisional = 0;
        }
    }
    #lstatFail(code = '') {
        // Windows just raises ENOENT in this case, disable for win CI
        /* c8 ignore start */
        if (code === 'ENOTDIR') {
            // already know it has a parent by this point
            const p = this.parent;
            p.#markENOTDIR();
        }
        else if (code === 'ENOENT') {
            /* c8 ignore stop */
            this.#markENOENT();
        }
    }
    #readlinkFail(code = '') {
        let ter = this.#type;
        ter |= ENOREADLINK;
        if (code === 'ENOENT')
            ter |= ENOENT;
        // windows gets a weird error when you try to readlink a file
        if (code === 'EINVAL' || code === 'UNKNOWN') {
            // exists, but not a symlink, we don't know WHAT it is, so remove
            // all IFMT bits.
            ter &= IFMT_UNKNOWN;
        }
        this.#type = ter;
        // windows just gets ENOENT in this case.  We do cover the case,
        // just disabled because it's impossible on Windows CI
        /* c8 ignore start */
        if (code === 'ENOTDIR' && this.parent) {
            this.parent.#markENOTDIR();
        }
        /* c8 ignore stop */
    }
    #readdirAddChild(e, c) {
        return (this.#readdirMaybePromoteChild(e, c) ||
            this.#readdirAddNewChild(e, c));
    }
    #readdirAddNewChild(e, c) {
        // alloc new entry at head, so it's never provisional
        const type = entToType(e);
        const child = this.newChild(e.name, type, { parent: this });
        const ifmt = child.#type & IFMT;
        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
            child.#type |= ENOTDIR;
        }
        c.unshift(child);
        c.provisional++;
        return child;
    }
    #readdirMaybePromoteChild(e, c) {
        for (let p = c.provisional; p < c.length; p++) {
            const pchild = c[p];
            const name = this.nocase
                ? normalizeNocase(e.name)
                : normalize(e.name);
            if (name !== pchild.#matchName) {
                continue;
            }
            return this.#readdirPromoteChild(e, pchild, p, c);
        }
    }
    #readdirPromoteChild(e, p, index, c) {
        const v = p.name;
        // retain any other flags, but set ifmt from dirent
        p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e);
        // case sensitivity fixing when we learn the true name.
        if (v !== e.name)
            p.name = e.name;
        // just advance provisional index (potentially off the list),
        // otherwise we have to splice/pop it out and re-insert at head
        if (index !== c.provisional) {
            if (index === c.length - 1)
                c.pop();
            else
                c.splice(index, 1);
            c.unshift(p);
        }
        c.provisional++;
        return p;
    }
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat() {
        if ((this.#type & ENOENT) === 0) {
            try {
                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
                return this;
            }
            catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync() {
        if ((this.#type & ENOENT) === 0) {
            try {
                this.#applyStat(this.#fs.lstatSync(this.fullpath()));
                return this;
            }
            catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    #applyStat(st) {
        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid, } = st;
        this.#atime = atime;
        this.#atimeMs = atimeMs;
        this.#birthtime = birthtime;
        this.#birthtimeMs = birthtimeMs;
        this.#blksize = blksize;
        this.#blocks = blocks;
        this.#ctime = ctime;
        this.#ctimeMs = ctimeMs;
        this.#dev = dev;
        this.#gid = gid;
        this.#ino = ino;
        this.#mode = mode;
        this.#mtime = mtime;
        this.#mtimeMs = mtimeMs;
        this.#nlink = nlink;
        this.#rdev = rdev;
        this.#size = size;
        this.#uid = uid;
        const ifmt = entToType(st);
        // retain any other flags, but set the ifmt
        this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED;
        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
            this.#type |= ENOTDIR;
        }
    }
    #onReaddirCB = [];
    #readdirCBInFlight = false;
    #callOnReaddirCB(children) {
        this.#readdirCBInFlight = false;
        const cbs = this.#onReaddirCB.slice();
        this.#onReaddirCB.length = 0;
        cbs.forEach(cb => cb(null, children));
    }
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
            if (allowZalgo)
                cb(null, []);
            else
                queueMicrotask(() => cb(null, []));
            return;
        }
        const children = this.children();
        if (this.calledReaddir()) {
            const c = children.slice(0, children.provisional);
            if (allowZalgo)
                cb(null, c);
            else
                queueMicrotask(() => cb(null, c));
            return;
        }
        // don't have to worry about zalgo at this point.
        this.#onReaddirCB.push(cb);
        if (this.#readdirCBInFlight) {
            return;
        }
        this.#readdirCBInFlight = true;
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
            if (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            else {
                // if we didn't get an error, we always get entries.
                //@ts-ignore
                for (const e of entries) {
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            this.#callOnReaddirCB(children.slice(0, children.provisional));
            return;
        });
    }
    #asyncReaddirInFlight;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async readdir() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        if (this.#asyncReaddirInFlight) {
            await this.#asyncReaddirInFlight;
        }
        else {
            /* c8 ignore start */
            let resolve = () => { };
            /* c8 ignore stop */
            this.#asyncReaddirInFlight = new Promise(res => (resolve = res));
            try {
                for (const e of await this.#fs.promises.readdir(fullpath, {
                    withFileTypes: true,
                })) {
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            catch (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            this.#asyncReaddirInFlight = undefined;
            resolve();
        }
        return children.slice(0, children.provisional);
    }
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        try {
            for (const e of this.#fs.readdirSync(fullpath, {
                withFileTypes: true,
            })) {
                this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
        }
        catch (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
        }
        return children.slice(0, children.provisional);
    }
    canReaddir() {
        if (this.#type & ENOCHILD)
            return false;
        const ifmt = IFMT & this.#type;
        // we always set ENOTDIR when setting IFMT, so should be impossible
        /* c8 ignore start */
        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
            return false;
        }
        /* c8 ignore stop */
        return true;
    }
    shouldWalk(dirs, walkFilter) {
        return ((this.#type & IFDIR) === IFDIR &&
            !(this.#type & ENOCHILD) &&
            !dirs.has(this) &&
            (!walkFilter || walkFilter(this)));
    }
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    async realpath() {
        if (this.#realpath)
            return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
            return undefined;
        try {
            const rp = await this.#fs.promises.realpath(this.fullpath());
            return (this.#realpath = this.resolve(rp));
        }
        catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Synchronous {@link realpath}
     */
    realpathSync() {
        if (this.#realpath)
            return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
            return undefined;
        try {
            const rp = this.#fs.realpathSync(this.fullpath());
            return (this.#realpath = this.resolve(rp));
        }
        catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd](oldCwd) {
        if (oldCwd === this)
            return;
        const changed = new Set([]);
        let rp = [];
        let p = this;
        while (p && p.parent) {
            changed.add(p);
            p.#relative = rp.join(this.sep);
            p.#relativePosix = rp.join('/');
            p = p.parent;
            rp.push('..');
        }
        // now un-memoize parents of old cwd
        p = oldCwd;
        while (p && p.parent && !changed.has(p)) {
            p.#relative = undefined;
            p.#relativePosix = undefined;
            p = p.parent;
        }
    }
}
/**
 * Path class used on win32 systems
 *
 * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
 * as the path separator for parsing paths.
 */
export class PathWin32 extends PathBase {
    /**
     * Separator for generating path strings.
     */
    sep = '\\';
 è“ëé¤Ôñù!‹QÃæIåš­ bM¶ñI©Ø†ÀÅïámR£ÔMÁæÓ©äVz˜>‡·úß	â¯cóßXë“òsè_l¸…®~)êÇ|–uS¹zõbQ¢*ÓEå&ÔK°…öÂ3¤xj’÷°÷àË®iâ²º°úy'(¼¾&jî³õª¹ì•Œå'ÅaÅ¢6RYÓûax‹Å:¡Ö~·J´?!r”	Ï‡·¬dŠ\Xã-µg­ÚÑÌƒ®ã>¥—:ÙEçWìÚr”Áã¸ûæ$ËÍbØaN#j)Èôké<ÂÌÌmÅe '²zaJ
;H”Ş“¶İ\ôO±Q?XL†¿+ÆuA,úñioÙ:˜V™!I—%7s¡ÕşõÅ~÷µù‚‹B­ 8§¨{/1O|-¦³º—Cù”Ÿ.Yhâò$S§kÛ†)í@cAÇĞ,ÜÔÅøJö®ú®ÊíÔ»
ı‰V—ÂÃÈÈ ¥ÍP@	ÎıÅÆ˜®4eSÔåê¥¸««ƒSh‰€g•îùb;ƒÙŞó!xû\ı®`}‰J¡£>f ª¥é0÷Şì}Pl–Ï¶ˆÙó©íT{{>Oèu<+æÀa!¼:2W‰xfy‹ÁÑÀ&ÒÕñD`¥›™µ¾†Ø(¯Bú¦“Š†©î2åcôÉéîi§–¤,˜DP^t0¦DdïüM¯Ïç¼Í§ù	GMF7WtÔ<ÎêÎE=jÇ m©¥eyÚêg½•'ìÛÈª¹çgÖX­î¶*©Çª¸	‹(„Z~KBÇ‹üŞÏÚrB|ÊJ1éc<«M÷Šh&Ã÷M¨}`ª»,Zœw'ËÎ<©èöW¥=ö²yU9'G^:k’õsª>v¾ÛÔOz;¥$Êö[Ö|Ó^”Ó±Ãq‰°SÏ-è›x„›œ™Ë7ªT½‡x-5cd]‚¾ü—iÅ?Œ·&lÃ9sW)0ãeYÖ©ıVi‘¥A™ÖE«{ü½ëU%ÊÎÎ;sAR(£<wmZ%]:fÒzş\>[÷Å‹ Õx<_ş™AÊ#KfŞhö¬j9ëU?ôğPÖYÏ~Â)9=^ò7”rÓx9ÿ·ò‚«WæRz† ³Áßpu·œö!®:<[«[æiÓ\ŸàöÓşI¢´Ô TeâÏ<iß¹šå¼œ·³,UîCğE# íÓ¾­ZxaYµÈ>­ÑdyAÊet9¿Î4‹ëbyÕµòpNE“@ÓÕd²H€†Uúù9¿l ÕëEuV–I.ÑUíİf×`ri¬°OØY-P„ÎGÖâşYm²ş©oGÔeömµÂc[ÅAùRî“Í†×I@‰-åÂ¬fÇ›z*:¶)ãu¸öİ¸Ï3TysómÛl>ıÓZ‹³‚å)<Å¬²lIàÆƒElô¯h2
Æk?Ñ»#@­Öw¤|~…á¬)¯!Šx(;4¶XÍ ó¸’ıaî=‚´úÏ˜æR³*89ĞAniQ‰ò©ÌV¸Ïìš—/id‘ÿÔ›şº]ahÁä'­V±ÜLH¼ó‘fÊ>RÊ.l‘£Ô+r¬ÕR;I¤[Ò«d´ëBìô®R”Gã^s…®.LaÀz÷z8/RsVŠ¥e«šÕÎk—¡KƒOœÛLğ0.^4ùÉğÿµ^Ù4lÙò+˜x››<dåViı$mîáš=`ÓLÃåËb¹ÿ¨{ØÃ;ß;A[c'™Œ‰.8ğW–˜½
ïÔÕ7@i<à-“ĞĞI+–£•3áZnù ¶ŞÌÎ?'=«ô}ƒÚ¨aÕ–· \x·¶ºM¤|LÄ.,³+WÓÖpg_ÛË½ùîgX%o4i*›EáH[§e®âÈÚtZ¥î€ĞŠ/¸Ş>¥¨~Nª‚Q36¥ã£Ù‡¢å±ŸŞgyìçÔ\3oT/¹/({^Ê_ˆ7(:º† (ú|q.¬<¬9 mËôQÍ†•ì$ycFRGW„ëGryºRÚ¾¥ƒ[“x«éºJG=P±S¯åbY-ìôG–?Ó©­Û”ı•Fša´€kYYâ¶åÚ€vÛƒ);¸©›«Ï ¼bh(Â»õĞ&}âëpî¬Ñ¯Œ:ïªšÌBÒŠŒŒ¦—«ÍÚÙ>2k»Y­L«ú÷#l×¹®‰ã¨ZMã.ò'âó©:Ïøj5eö×8EB[ùJ·Läeˆr<9!T<z]Ìö†/(nGˆ.çù7ìù–q¢öˆ%^+`òAó64´õ—rãÂĞ³¡Ø*rñÁºEª¥œ96u·‚Ì^fÚ™ ¾o§(»oÔŒÀ¦Bß0ƒÕMCiG6¦pe0*è,%ÖQ©nÖ Hë€ö'rBÓ´Ö~K%t³6’QJşà
¾ph`ê!AÇx%*pKç•¢™C oÖêióÎü˜íê4
‰Ïz~.Ó!HtŠ­òr•³p‹ÂÙµjµ¢š¤±“÷ ë'6%®¼²\Ã/AêÚßòê¥ÈNK¯V÷^pM»4Şõà(Ïc~Í?í™kx|íÁ·TßöÔ±T?÷ *;Ï{f,˜|j»¿çí™!ÿö¬hÛİñ¶®õêò,LvEFÎ­JÅÂmCù‹à°?‚‚hÈºÙ/¸ˆÂG¥Ò¿¼c–£Š	¡2±÷jÙ>‹sD#ñ_#ëhiô;ŠÏ°bÉi£¢ñHN«o­5<öç3i	Ó¿;I¿©šN=Ì}½%Æ…îEú´ÌpÊ1é®òúeFÓ~Kyq sèVÕ||EXd;îÎ-©³áfW…?Ÿ¡K7­ÚFºYÈKïÄ`Â³,‚š×ÕÆí×|LT¢Ñã™5¿¥Š‘T6G:üFØÈj¦ìTØ½ê—0«êŸí²¿¼òÓÜ6UsÁ“$*3Çæn!váGÆ]S.{.î(1ı\±êI¾½§*¥î}Ï'ÔJ¤<·\Çi,š˜£ºm(;9ëá±z#È›ÃäÃPîóÏÃfk–™äsG›m«¸#’«éNd&Š>øQœ¯©çËuDk£4ƒ ö.Xëå½è³`Åä«>¿ÅRq­¡ì1¹®U'õò’r9ÜJzš5	ºœíR[¯Âº´ÏÜÌÜÌ-Dó‡e;xM?J"Ã\5$ŞYÑ¤§8	IÑ_#úvTziFÿJød¨ÖXó\u w¿[–M¯Iş½ƒï¦Ü\Áú6Ù)ªB÷óJ¾ìçj½Mg„bÆ"¿Hk $M‡N†æ¾Ñ"Œ
·«×†:0['üse%_ÙSv·Ëúg«ËGù9n;Ë‡÷îÊƒ³9ºY‘/èmÕ¥Ôôf¾?¶NÔ[»Ä3œgÑX^`nN¸¹å¦ÉzçìsóºÈà@h—*ıO²×ùO˜‰W×Z‘…³tËxŸzûS‹Êªêiw•Z^ZS¦aŒ÷F\ësO(õ»„x‹Êœó¶É8–“×‚tså÷¥´$îÖ&—›Ã|â]{ÙÇ6ı7±û-fsY„µÌ.¶ºÜÍV®×ò^™İc‹Õ}ô1#Õ§!ÎÈkiàe_ìÌ$ê<Ÿ{Vß„®~ùóvƒİBo±·;3U9¾ô±4[€°ùu\qPÁÚ[”*Ë”òªÍÙ`wÃ@Ñ’“<±WÀ1-gİJeÖäÒqf·Œ±Ô!oR¾ä­ñ²˜-¯ ‰.¯]QEBLì¹©§ŞM*eL!ÉÕ	W›ì”».¸V`<u}/K3hM7àæ–Î2XVc÷ÑŞœKÃï˜'\*—Œr1uí€·iŞc¯vÁ9ã
e»[­›À3ÒÍj]¦3º	Ğ}É3\7siá6D¿³Y«´xÖc¶[‹á&Tè±s[¶«']Ö5§S ÃKO
vÎQÅ«C,8B°¥ aw_’ìµª=ıQ5Â$¿Dÿ¡ïÎÌAÑ!”rÓ\zïÁZ¯'Ñ6omæÑ¢ı›ïåş[;‰şŒWŞ™e©—)´*úÅÕù¬Î%¥z¤û|5g5•{¶Öö(KÚÄîæMšJ‰£³è,å¼Y­P%»»›dz½'bM {ñÙ$Á*ÑmÕª[Hã“k˜ª—£âyÎ7ô`òEû6×G¨tÅµB—ÍÔ°òsA,n3©pš×ïØûTÑ¹›Y®fùbÕ…> À©¿éÈù¶ŠAÀã6
ÇËS7×@/™ÃbÇ}D¥4·ÎÖŞ¡ˆ•>éµ:wªp„Sê4ƒR
í½­„1}$f^”“ú‚ìrQ¬F›Ğö­¾Œ0kªÊc—»“İ1Yç´ŞíŒyÓV•2I…•&­1ÅôA1ã„3¸ívl•Î‚pp—ç…4\"zĞæ)H±;*_»D|µ(a"äkÉWÉ¡è˜“êMıqv»cšcÅË4%5@i:Ë½Š½™][G÷¹Yì{¿_§–}÷·šÈ˜Óó»R/¨ÃE\MôZG—õ	!izå•T"Ód•Y5BMwº:>jn+ÍÔ’t©íiŠ]#ÇEûá“}6,­µ2· Ó<Å.”§Üa‚Ÿ¼Mt²èK¾šĞà¬¾gşœ¡ò¯&nÀ¡CEV&Ô9‘!t–H`I¯„ÆòÎ9…Q'£ÚÏòµâåªåÎ–/ãŠÁ¼D)êyöNî&¤"Mvİ(¡X¶Ôû¢4j¼ãsÍüàK3Ös›H«5›ÊÖêªs?S¸Í£o®¬m«áU¸Ë.ñ:Çºér©Ğ2I¨i‡$í¹—²{÷Tv´<š‹êİ~‡¬I6Ï{ÈZ}:hu¨÷m×!krv"²–û™Èû‚‹4À&Ãõ!üÎzÎt+ê÷‘µëíûuúŸX¥/CVùsm,Y¥F›ó]…a˜dnH¢vØÙ(QsÊšlìğúR¤Vİ}µ:‘^§,½ì{ÿø¹²øvİÇKcF«ò…Z¯LÙ5Cı2“g
eŠ>ÑµR€mVìx_µG©R?¥ÄKx <|d:×èßÕ¢<¶Gßùœ‚zAÆqZLöN´ÖJÎ·Û}‰ò&YoÙl¾XfyâU4y»B¤Fk<ÃMÎ¢vè§è;×[%¯FP{¿üÏHCçl+Œ¤ Í3rÍ‚Ğ`-q*…m% 
A4Ğ—l ø³˜Ÿ¤æØ³Ÿ×ÍÏU˜Ò.<JÚ¾“@Ê?ÚpğxTxmm/r.Ÿ65AâE_ÃoµÑÍ)Ö•ª›?ûüÌ¬xc÷#š‚ú;oşv°ÁÛ@b@0êˆÜ‹°-!‹ÖŒ³ä¶hC#äÔ˜¡&¬uHÛZŞW6ZZôü¶<8ĞeÄ²zÆş#T„À*™ption(fs);
        if (cwd instanceof URL || cwd.startsWith('file://')) {
            cwd = fileURLToPath(cwd);
        }
        // resolve and split root, and then add to the store.
        // this is the only time we call path.resolve()
        const cwdPath = pathImpl.resolve(cwd);
        this.roots = Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        this.#resolveCache = new ResolveCache();
        this.#resolvePosixCache = new ResolveCache();
        this.#children = new ChildrenCache(childrenCacheSize);
        const split = cwdPath.substring(this.rootPath.length).split(sep);
        // resolve('/') leaves '', splits to [''], we don't want that.
        if (split.length === 1 && !split[0]) {
            split.pop();
        }
        /* c8 ignore start */
        if (nocase === undefined) {
            throw new TypeError('must provide nocase setting to PathScurryBase ctor');
        }
        /* c8 ignore stop */
        this.nocase = nocase;
        this.root = this.newRoot(this.#fs);
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split) {
            const l = len--;
            prev = prev.child(part, {
                relative: new Array(l).fill('..').join(joinSep),
                relativePosix: new Array(l).fill('..').join('/'),
                fullpath: (abs += (sawFirst ? '' : joinSep) + part),
            });
            sawFirst = true;
        }
        this.cwd = prev;
    }
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path = this.cwd) {
        if (typeof path === 'string') {
            path = this.cwd.resolve(path);
        }
        return path.depth();
    }
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache() {
        return this.#children;
    }
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths) {
        // first figure out the minimum number of paths we have to test
        // we always start at cwd, but any absolutes will bump the start
        let r = '';
        for (let i = paths.length - 1; i >= 0; i--) {
            const p = paths[i];
            if (!p || p === '.')
                continue;
            r = r ? `${p}/${r}` : p;
            if (this.isAbsolute(p)) {
                break;
            }
        }
        const cached = this.#resolveCache.get(r);
        if (cached !== undefined) {
            return cached;
        }
        const result = this.cwd.resolve(r).fullpath();
        this.#resolveCache.set(r, result);
        return result;
    }
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolvePosix(...paths) {
        // first figure out the minimum number of paths we have to test
        // we always start at cwd, but any absolutes will bump the start
        let r = '';
        for (let i = paths.length - 1; i >= 0; i--) {
            const p = paths[i];
            if (!p || p === '.')
                continue;
            r = r ? `${p}/${r}` : p;
            if (this.isAbsolute(p)) {
                break;
            }
        }
        const cached = this.#resolvePosixCache.get(r);
 ©öû¶3LÎSbf;" ‰Êg”Í4mU[¢*ĞTË®òø‰,³c-MêÛ‡Djæ^·-UÜŠt9G]fÌ¨gï‚f–)­³ÌWeh4áˆn	ª&÷zÓœ|EWÑm\ª0ítI£\¢õ’_g¬e¥q&k2Ï†<<©ƒ»Kú'É{kŠ‘u®ˆfÑÒê¡Ù­MMkG?Ëùpm7•¬·’Ü\f)’½–yÚµ4ÉÓ%;ÃÌ’NÊt_“	5ÔgmKä¸š¶Ÿ EèsSC}YR³OÌjM ±æ‡m²»ĞƒÇ™Šéq YÊµ53éá Q1%·FÅMØUUQ­…w@£ô¶ƒ™ƒQh¬R‚?ê¶³´Îi*L	İU=Ÿš‰:™ÙfšQo©DbíTÂyU&émf´ë4…²²LË6¼6ˆDÚbÎ¨Õ´Í²L´r>a´ì<™&ÉÉÓ3Í¬»0dXNÉX˜„T^ÑŠ3LÎË@µM`ÍåÓ|HŠW
àÜš¢ ¶Esce²#`9™`F–”2ØùšOCy^g~µªom•Ì@ËtÎn;d6“Œ2+§ó3àÖ¼¨ò$¸†¢¸djØÓh’eL³eÔYšhSÓ ¦QÁ‰[Tªòà<N3’mg.'%Kƒ51Df·Z«V•$•Q§QbÊí³°Ì€·5MršqX—®x„Tu¦‚Z‡™Ã.Ğx™÷]F3&Œ³YeO¾Ÿ˜•dÛeÀåÓ,¡ÍÂ>¦irÚò*¥‰VŠœ·2>¨e¨Ëò †™eg¢Ö‰6K¤Ú0îô¸¨ÓPˆ¥¹œPO3XrÉ1u%™ä/*ä
CNú1•F	e^ QbI$Í3‰›Q6ÁÜş¶IHe”g¹uæ©|R ‰&›œg2Š©%ËJ‘wNjGH¶'“m7GhÀ¨•q&ºIREuÎ¨9Ê¦^u ¤Ä{Â;ÛI&ó€—¡GÛ*êrsÖMNDÊò›¦x,ÈxãÔ¥[îºëvâÊm7.ÔéëK¹î^ç®İ“IA%¶6]E»—%K4%Ş¸r6ÉvC®Ûéøn0B6ÊvSˆ8—³àİØ±.ÔÙ{ùî¨®º÷6'u“:L’2O¢ìJ]D-ÔnÇØML¾ A-)jêí­ûqÊ®f/Ş ¢™QÜÉÎ^éÊ‘dãÙnrIì– ¤¹tíeÉºÀ#¹£º‚¦%ÙRÉ^È%G”¡äˆD®²n“Ğ´Äyùq/”Õd¹¡¸ºNpÄcA¨ö±ÜPÉu»­¾’rÛm·®cçe¼Ÿvãí¼›nÜË¾ÎËQÊ"lI=IS •ë‡%¶@Ö%œÒÈ»´öî»Ÿw;‘ÌdÒÉ0J‚2 †¸=!ë	Qò…üø±r´±ä^ç“nÈQ+ÊtËë¶µúUß;n÷ù„jr2:¹×)9ê˜\á$79ã ´–tAÒ‘%KMYŞÛÛLyøá6¨ä)7ÔùØ1dp>~ÜzívâR¾ü¸à?SÚ•®¯ïË’íÆuN¦Ûn*À3×Ù(ïBö-(ÆâÅÈËĞÂ„Eò	9ÜHd„nƒKÃ.µÆ”Qß(İ%D%pw6İ	‡¿p“É?‘)`­–Ôån§n³×Ù¸·ñ.®“²c»I·–
ßò@ï®r”$yF
m,y×©+y÷IÙÉãÉ—ñvÛ`"¹îgôn§d_»'ÛíÜJ®›nçcÉQğvêê>¦Ùí’yRYÎ×’wÁjœ’”­Á{ŞM–¹S5&UOÊPòIGBI?™¬Êš³‰’?^D}{ud‹pñŞ‡H/‘H"ñvL²‰$r¹×p¸8ˆ÷âÒıØÙy Iİ^É%;ënL÷.NÉuC)î-UÏ{H$ÁÉÆºMu;ïöíÅ½ÛÙzwsLÈ,“?<I·ë½@úúî:¡’å¶›ngôîÆw;v>/7†L:~B	fJ o»KÖu
hT²“¬¥Wî»Ih';&­DâMşˆôåTnX+I:¾ŒK÷Óéû:Y×	Ù1Ş{Ín¹™ì”¼K¹E£ ED¡sÚYK	»{O:w}uñ¾ì„Ìİ“¡N»¡vÓMÙék7“åv{R¯¦ $Ë­¹±“îçcº}tKŸÎÇwC™œ°jÉ»CFÏO”¼ñÆíuöÒK7İ$´Ò…LŞ­{2¤Ş]Ç¤
Ój¼xõĞÎ-“à6Æ;êt|ùñcÈÎèÉ—ºvß}7ùŠ/©	¢¢ÂÂäI'3©åóY7ŞrŞ-w4útî6ó2İQ»{PÇºrSv{¼ZuMñZ¦Àõ•Üx2Pâë{·óqocß^Òz;ÁLYn“‘„Ñ\ÁÅ$ëäÆx;é¾}^vJîÆvËí¼¬+ÀI·ä»)Ov{úiÇêºSr€n_]¶Ûy·İíîËN¹Ÿv«n'´nSÓM¹o»İ®q&½<Œ.±|I.’¹mµÆ'ŒÌË“O;B{Dİ.¹k'oJdbD¦(gÒ\>O«¡¬Û&@5<-IK‰–î§$K{ù"ÈÔ›R;ÉX0ÏÜÄXtYstãÁ…i|ØØ’È‹z×m£j™¤6@.H6­MÇ^TmWìzjÎhãçÑ¦f,w×‰ë8×k`PmiÆ¥jX¦ë`Ò#Ûİ+ÓíÃj›¤Í*¿{µ€gƒ¨µ{ÈytZş¥şzJœµŠ‹*´‹7·#½ÜÆ¤ Ş“äõ<ÒãÍÿàÒ¸ëpT™î·ÚCÈ_µg©kr¡£DTß8¦,êç-|ü'=˜'&ò;¿ñ.ïSOÇ­ñv¡N–‹ÛØÙ=Ùu\é©Ÿ„,ºÅ#ªí¦Üõc oÙkH
µåP‡—¶Ê†Æ`úíNT£±T 0°	ËÚöšQ½ãØÚC	4äÕlºÍ\^skàt÷0K‚ÆŞş£3O®;wíÆşä±åX(ZVi\ 3º2I®‘[íwZgAÎĞ%?j_0ˆòÂoó© wúìÂöè–ÑÌ ….ìš1–Š5}n™o°ôÀL!ÂÒŸ¿^¦÷ÛÜ…7¥!ÒækµÈ’}5¦nÌĞt\ïd³yes|—³K©ú‹°Òğ{.í—8"½;oÜIYÇ`2}w:D«}~ş¹›½İiONÎ]øËòU/¶Ğ·ÅÿûáÊcuÿ{¢…¾ııi¡o«ß]y¬í%òÈ/\|´ó	YÇ'r<AÏ:ñ­ãØñeÇwñR¥ãÜø<TÇÛ”·w²ß9şäGÇ/tça;-§mwÎ(^Üó,ºçŸ£G„3–/³¼DÇ³|ìø‡eoãE¹ãSœşË›Áw¦H~¶y;êÇ¬±?ŞûøÑLş¼¾êû¢ÕwyõE_o4š?¤ù¨~–|¼dùÅ·-_Wñ)úšg‡ãü;_ÑâU¾ÿ´ñkË')àÆï‰[~Dô®ãş–øU†³üøY4¿Š×;w?šsãév| /~Pt"t¬x-Ò1Üñe–RByO^X*>D‰†ÊÃèó‰^›h¨w	~P|ìğñM{{| ÛãùºÿŞçMQÇÌÇÿ´ÃÇó.Ï[üËyÖø¡£—/âİ‡~hÌkÊÖÆ·0çó˜ò­ÜW)õ›rÙù‡‘í:/«º}†¶zÛ×.‡åsxÚ?Á%áßOr¿ùÕ%)!ÿ@Ÿ³ÏÄÌ¾EuŞ|û%™õó‡l¼ğ}6lÌËsrH³í$ó%rËféÃN¹¾¤_d/ı^¡L{Tæ'/ïg³={?¥ËòÓµGoäªŞß^ó}Ïù8?©\Ÿ·ÍéÏ´-ç[‘Òß/)ãÿco{Êó{L%?É|•0÷,m+/ôÖïä6
õüÓî=ÍúÕ&ßKĞC³¯8Mi«o_*ùâZzÕ_ÒVñçiúüRúøÚv¶æ²ÿ£•ÇŸöÁ·¯Xª&ó÷˜óè×·“=‡DšíwÃÇŠşêoÙ,ûûÈ³ôQ“¬–İP²“„ÿ-‰dòáO—;£$?; ?zCÈ%;-wßR?®O…k¿£)|÷€ÖˆÙxÙ2v~@{¼ìş¹Á0Û/t¹çäCó~ú˜>6´İ\{Î¿(kŸUÍy>“iÙèimHŸá=şl_>Vô¹µœíİ©ı¬}fm›m#~a¦eL4-v¾!Ïó»Í˜¾[©;Úà–‡¶ŞÉäçÛ”Ú 7ë¿¸'™ÿpóL’ñü,áÏ·ÀÆ‡O¸>ã°òGŠ_Ú-ı(Ší|“Ò_Ñ~ü˜İüŒ~wÊ¿Iö0I’Œ>¡¬~”ÌŸùùWª?hg·Eÿ\ÉJïC[~öÙçX÷[Ğ÷Ü+ú<e;P.Ê->D[xüxúñ8ß"Îì	7¿´ß=gdŸGµôc~Ï¦üq«ç¦có«ÉŸa’Süç Ï¾_fj÷÷Y¦0¿BË~Óıå€¶·¯}dáë+ªÙ-
Z´}¾mÆ«øÓöü||9?Ç8~W.^å/Ëş[c|øK»4|İrß•şìX¾êù”=’ıìaõ9Ş²ñOl>Î–şÂßóûµ¢pïã›ğ	NäJıw¹¸ïÒ®=o9ä˜o°‹ôK¹¦Àuí/IÍõß6ŸŸ$[İ.‰kEøw|Æ“­Î˜u©”]²Ãüëj—â§®ÉOÈ?ñ¾=Gãïãü¨·~nù*ãóşğ×½VFt|_&{Ì§ıeMjù9û!®¯ü“wŠõó
™ IÍ¯~ÓdºáÃ|ß+fSgû>É”ãŞÿwÍ÷z{²ù9úŸƒÓSï—Š…Aê«æ2~¿¬EãåÁ–_d©éØC®1ö˜Wv«~ã8ãë_’ßS{mãÜÆ¦¥–?b³#Gï×pZI}Vï³Ü¾‡J6÷&%õxÙNV˜¬Iª7“µ—ïó³&©•“ÂÆ/É¸~ç,ßoè”º¿(tä­óynÎ¯ªÂ³CÒõM•ÂñÅ¥ºIê¤Øå§Óq”\6µn«W•'÷"8õB†Ó#öjÛĞÛÿT«á‚oÚ—ÛÜ›Œ¯+3üÒJêÇÏÚoz:Ş$v”A«öÔLFŸ%;M€áßF=·)>cÉ¡éM-@b•Éšã$dbK¹GÈ$H„Ì8%dM+şåĞÁbØzâßTÍ[ï•C3åCbïrhßöshe¿ã-=sh~sh ­êq™C«×zçĞqÂsèY1Ñ¡‘ü±Ó¡GÅ'›•üÔ¡}üÕ¡™™â?±ÍMâ?¹Më½‹z™œÁßäºfÂîÚUÛJL8áÄğÏ|‡¦\:tš*½C²¾C×oX¤‡fàğ¿†‡.
ÿ‡   }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = entry.readlinkSync();
        return withFileTypes ? e : e?.fullpath();
    }
    async realpath(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = await entry.realpath();
        return withFileTypes ? e : e?.fullpath();
    }
    realpathSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = entry.realpathSync();
        return withFileTypes ? e : e?.fullpath();
    }
    async walk(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const walk = (dir, cb) => {
            dirs.add(dir);
            dir.readdirCB((er, entries) => {
                /* c8 ignore start */
                if (er) {
                    return cb(er);
                }
                /* c8 ignore stop */
                let len = entries.length;
                if (!len)
                    return cb();
                const next = () => {
                    if (--len === 0) {
                        cb();
                    }
                };
                for (const e of entries) {
                    if (!filter || filter(e)) {
                        results.push(withFileTypes ? e : e.fullpath());
                    }
                    if (follow && e.isSymbolicLink()) {
                        e.realpath()
                            .then(r => (r?.isUnknown() ? r.lstat() : r))
                            .then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
                    }
                    else {
                        if (e.shouldWalk(dirs, walkFilter)) {
                            walk(e, next);
                        }
                        else {
                            next();
                        }
                    }
                }
            }, true); // zalgooooooo
        };
        const start = entry;
        return new Promise((res, rej) => {
            walk(start, er => {
                /* c8 ignore start */
                if (er)
                    return rej(er);
                /* c8 ignore stop */
                res(results);
            });
        });
    }
    walkSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set([entry]);
        for (const dir of dirs) {
            const entries = dir.readdirSync();
            for (const e of entries) {
                if (!filter || filter(e)) {
                    results.push(withFileTypes ? e : e.fullpath());
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync())))
                        continue;
                    if (r.isUnknown())
                        r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
        return results;
    }
    /**
     * Support for `for await`
     *
     * Alias for {@link PathScurryBase.iterate}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
    iterate(entry = this.cwd, options = {}) {
        // iterating async over the stream is significantly more performant,
        // especially in the warm-cache scenario, because it buffers up directory
        // entries in the background instead of waiting for a yield for each one.
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            options = entry;
            entry = this.cwd;
        }
        return this.stream(entry, options)[Symbol.asyncIterator]();
    }
    /**
     * Iterating over a PathScurry performs a synchronous walk.
     *
     * Alias for {@link PathScurryBase.iterateSync}
     */
    [Symbol.iterator]() {
        return this.iterateSync();
    }
    *iterateSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        if (!filter || filter(entry)) {
            yield withFileTypes ? entry : entry.fullpath();
        }
        const dirs = new Set([entry]);
        for (const dir of dirs) {
            const entries = dir.readdirSync();
            for (const e of entries) {
                if (!filter || filter(e)) {
                    yield withFileTypes ? e : e.fullpath();
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync())))
                        continue;
                    if (r.isUnknown())
                        r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
    }
    stream(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = new Minipass({ objectMode: true });
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const queue = [entry];
        let processing = 0;
        const process = () => {
            let paused = false;
            while (!paused) {
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0)
                        results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const onReaddir = (er, entries, didRealpaths = false) => {
                    /* c8 ignore start */
                    if (er)
                        return results.emit('error', er);
                    /* c8 ignore stop */
                    if (follow && !didRealpaths) {
                        const promises = [];
                        for (const e of entries) {
                            if (e.isSymbolicLink()) {
                                promises.push(e
                                    .realpath()
                                    .then((r) => r?.isUnknown() ? r.lstat() : r));
                            }
                        }
                        if (promises.length) {
                            Promise.all(promises).then(() => onReaddir(null, entries, true));
                            return;
                        }
                    }
                    for (const e of entries) {
                        if (e && (!filter || filter(e))) {
                            if (!results.write(withFileTypes ? e : e.fullpath())) {
                                paused = true;
                            }
                        }
                    }
                    processing--;
                    for (const e of entries) {
                        const r = e.realpathCached() || e;
                        if (r.shouldWalk(dirs, walkFilter)) {
                            queue.push(r);
                        }
                    }
                    if (paused && !results.flowing) {
                        results.once('drain', process);
                    }
                    else if (!sync) {
                        process();
                    }
                };
                // zalgo containment
                let sync = true;
                dir.readdirCB(onReaddir, true);
                sync = false;
            }
        };
        process();
        return results;
    }
    streamSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = new Minipass({ objectMode: true });
        const dirs = new Set();
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const queue = [entry];
        let processing = 0;
        const process = () => {
            let paused = false;
            while (!paused) {
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0)
                        results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const entries = dir.readdirSync();
                for (const e of entries) {
                    if (!filter || filter(e)) {
                        if (!results.write(withFileTypes ? e : e.fullpath())) {
                            paused = true;
                        }
                    }
                }
                processing--;
                for (const e of entries) {
                    let r = e;
                    if (e.isSymbolicLink()) {
                        if (!(follow && (r = e.realpathSync())))
                            continue;
                        if (r.isUnknown())
                            r.lstatSync();
                    }
                    if (r.shouldWalk(dirs, walkFilter)) {
                        queue.push(r);
                    }
                }
            }
            if (paused && !results.flowing)
                results.once('drain', process);
        };
        process();
        return results;
    }
    chdir(path = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;
        this.cwd[setAsCwd](oldCwd);
    }
}
/**
 * Windows implementation of {@link PathScurryBase}
 *
 * Defaults to case insensitve, uses `'\\'` to generate path strings.  Uses
 * {@link PathWin32} for Path objects.
 */
export class PathScurryWin32 extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = '\\';
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, win32, '\\', { ...opts, nocase });
        this.nocase = nocase;
        for (let p = this.cwd; p; p = p.parent) {
            p.nocase = this.nocase;
        }
    }
    /**
     * @internal
     */
    parseRootPath(dir) {
        // if the path starts with a single separator, it's not a UNC, and we'll
        // just get separator as the root, and driveFromUNC will return \
        // In that case, mount \ on the root from the cwd.
        return win32.parse(dir).root.toUpperCase();
    }
    /**
     * @internal
     */
    newRoot(fs) {
        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
        return (p.startsWith('/') || p.startsWith('\\') || /^[a-z]:(\/|\\)/i.test(p));
    }
}
/**
 * {@link PathScurryBase} implementation for all posix systems other than Darwin.
 *
 * Defaults to case-sensitive matching, uses `'/'` to generate path strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
export class PathScurryPosix extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = '/';
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = false } = opts;
        super(cwd, posix, '/', { ...opts, nocase });
        this.nocase = nocase;
    }
    /**
     * @internal
     */
    parseRootPath(_dir) {
        return '/';
    }
    /**
     * @internal
     */
    newRoot(fs) {
        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
        return p.startsWith('/');
    }
}
/**
 * {@link PathScurryBase} implementation for Darwin (macOS) systems.
 *
 * Defaults to case-insensitive matching, uses `'/'` for generating path
 * strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
export class PathScurryDarwin extends PathScurryPosix {
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, { ...opts, nocase });
    }
}
/**
 * Default {@link PathBase} implementation for the current platform.
 *
 * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.
 */
export const Path = process.platform === 'win32' ? PathWin32 : PathPosix;
/**
 * Default {@link PathScurryBase} implementation for the current platform.
 *
 * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on
 * Darwin (macOS) systems, {@link PathScurryPosix} on all others.
 */
export const PathScurry = process.platform === 'win32'
    ? PathScurryWin32
    : process.platform === 'darwin'
        ? PathScurryDarwin
        : PathScurryPosix;
//# sourceMappingURL=index.js.map